const { SlashCommandBuilder, EmbedBuilder, AttachmentBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, MessageFlags } = require("discord.js");
const axios = require("axios");
const { Chess } = require("chess.js");

// Map pour stocker les puzzles en attente de solution (par guildId au lieu de userId)
const pendingPuzzles = new Map();

// Fonction pour traduire les difficult√©s
const translateDifficulty = (difficulty) => {
  const difficultyMap = {
    'easiest': 'Tr√®s facile',
    'easier': 'Facile',
    'normal': 'Normal',
    'harder': 'Difficile',
    'hardest': 'Tr√®s difficile'
  };
  return difficultyMap[difficulty] || difficulty;
};

// Fonction pour convertir la notation anglaise vers fran√ßaise
const convertToFrench = (move) => {
  return move
    .replace(/K/g, 'R')  // King -> Roi
    .replace(/Q/g, 'D')  // Queen -> Dame
    .replace(/R/g, 'T')  // Rook -> Tour
    .replace(/B/g, 'F')  // Bishop -> Fou
    .replace(/N/g, 'C'); // Knight -> Cavalier
};

// Fonction pour convertir la notation fran√ßaise vers anglaise
const convertToEnglish = (move) => {
  return move
    .replace(/R/g, 'K')  // Roi -> King
    .replace(/D/g, 'Q')  // Dame -> Queen
    .replace(/T/g, 'R')  // Tour -> Rook
    .replace(/F/g, 'B')  // Fou -> Bishop
    .replace(/C/g, 'N'); // Cavalier -> Knight
};

const commandName = "puzzle";
const commandInfo = "Jouer √† un puzzle d'√©checs depuis Lichess";
const commandDescription = "R√©cup√®re un puzzle d'√©checs al√©atoire depuis Lichess avec diff√©rents niveaux de difficult√©";

module.exports = {
  info: { commandName, commandInfo, commandDescription },
  data: new SlashCommandBuilder()
    .setName(commandName)
    .setDescription(commandInfo)
    .addStringOption(option =>
      option
        .setName('difficulte')
        .setDescription('Niveau de difficult√© du puzzle')
        .setRequired(false)
        .addChoices(
          { name: 'Tr√®s facile', value: 'easiest' },
          { name: 'Facile', value: 'easier' },
          { name: 'Normal', value: 'normal' },
          { name: 'Difficile', value: 'harder' },
          { name: 'Tr√®s difficile', value: 'hardest' }
        )
    ),

  async execute(interaction) {
    try {
      // Gestion des boutons
      if (interaction.isButton()) {
        const guildId = interaction.guild.id;

        if (interaction.customId === 'play_move') {
          await showMoveModal(interaction);
          return;
        } else if (interaction.customId === 'show_solution') {
          const userPuzzle = pendingPuzzles.get(guildId);

          if (!userPuzzle) {
            return await interaction.reply({
              content: '‚ùå Aucun puzzle en cours sur ce serveur',
              flags: MessageFlags.Ephemeral
            });
          }

          await showSolution(interaction, userPuzzle);
          return;
        } else if (interaction.customId === 'hint_button') {
          const userPuzzle = pendingPuzzles.get(guildId);

          if (!userPuzzle) {
            return await interaction.reply({
              content: '‚ùå Aucun puzzle en cours sur ce serveur',
              flags: MessageFlags.Ephemeral
            });
          }

          await showHint(interaction, userPuzzle);
          return;
        }
      }

      // Gestion des modals
      if (interaction.isModalSubmit()) {
        if (interaction.customId === 'move_modal') {
          const userMove = interaction.fields.getTextInputValue('move_input');
          const guildId = interaction.guild.id;

          const userPuzzle = pendingPuzzles.get(guildId);

          if (!userPuzzle) {
            return await interaction.reply({
              content: '‚ùå Aucun puzzle en cours sur ce serveur',
              flags: MessageFlags.Ephemeral
            });
          }

          await handleMove(interaction, userPuzzle, userMove);
          return;
        }
      }

      // Gestion des slash commands
      const difficulty = interaction.options.getString('difficulte') || 'normal';
      const guildId = interaction.guild.id;

      // Nettoyer l'ancien puzzle s'il existe
      if (pendingPuzzles.has(guildId)) {
        pendingPuzzles.delete(guildId);
      }

      await createNewPuzzle(interaction, difficulty, guildId);

    } catch (error) {
      console.error("Erreur dans la commande puzzle:", error);

      const errorEmbed = new EmbedBuilder()
        .setColor('#FF0000')
        .setTitle('‚ùå Erreur')
        .setDescription('Une erreur s\'est produite lors de l\'ex√©cution de la commande.')
        .setTimestamp();

      if (interaction.replied || interaction.deferred) {
        await interaction.editReply({ embeds: [errorEmbed] });
      } else {
        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
      }
    }
  }
};

const createNewPuzzle = async (interaction, difficulty, guildId) => {
  await interaction.deferReply();

  try {
    const response = await axios.get(`https://lichess.org/api/puzzle/next?difficulty=${difficulty}`);
    const puzzleData = response.data;

    // Charger le PGN avec chess.js
    const chess = new Chess();
    chess.loadPgn(puzzleData.game.pgn);

    // Obtenir le FEN de la position
    const fen = chess.fen();

    // D√©terminer qui doit jouer
    const fenParts = fen.split(' ');
    const activeColor = fenParts[1];

    // G√©n√©rer l'image de l'√©chiquier
    let imageUrl = `https://fen2image.chessvision.ai/${encodeURIComponent(fen)}`;
    if (activeColor === 'b') {
      imageUrl += '?turn=black&pov=black';
    } else {
      imageUrl += '?turn=white&pov=white';
    }

    const imageResponse = await axios.get(imageUrl, { responseType: 'arraybuffer' });
    const imageBuffer = Buffer.from(imageResponse.data, 'binary');
    const attachment = new AttachmentBuilder(imageBuffer, { name: 'chess_position.png' });

    // Cr√©er l'embed (sans l'image qui sera s√©par√©e, sans th√®mes ni coups attendus)
    const embed = new EmbedBuilder()
      .setColor('#0099FF')
      .setTitle('üß© Nouveau Puzzle d\'√âchecs')
      .addFields(
        { name: '‚≠ê Rating', value: `${puzzleData.puzzle.rating}`, inline: true },
        { name: 'üéØ Difficult√©', value: translateDifficulty(difficulty), inline: true },
        { name: 'üë§ Trait aux', value: activeColor === 'w' ? 'Blancs' : 'Noirs', inline: true },
        { name: 'üéÆ Parties jou√©es', value: `${puzzleData.puzzle.plays}`, inline: true }
      )
      .setDescription('**√Ä vous de jouer !**\nCliquez sur les boutons ci-dessous pour interagir avec le puzzle')
      .setTimestamp()
      .setFooter({ text: 'Puzzle fourni par Lichess.org' });

    const reply = await interaction.editReply({
      files: [attachment], // Image s√©par√©e de l'embed
      embeds: [embed],
      components: [createPuzzleButtons(), createHintButton()]
    });

    // Stocker les donn√©es du puzzle avec guildId
    pendingPuzzles.set(guildId, {
      messageId: reply.id,
      solution: puzzleData.puzzle.solution,
      pgn: puzzleData.game.pgn,
      fen: fen,
      userMoves: [],
      solvers: [], // Tableau pour stocker qui a trouv√© chaque coup
      difficulty: difficulty,
      rating: puzzleData.puzzle.rating,
      themes: puzzleData.puzzle.themes,
      plays: puzzleData.puzzle.plays,
      hintLevel: 0 // Niveau d'indice (0 = aucun, 1 = nb coups, 2 = th√®mes, 3 = premi√®re lettre)
    });

  } catch (error) {
    console.error("Erreur lors de la cr√©ation du puzzle:", error);

    const errorEmbed = new EmbedBuilder()
      .setColor('#FF0000')
      .setTitle('‚ùå Erreur')
      .setDescription('Impossible de r√©cup√©rer un puzzle depuis Lichess. Veuillez r√©essayer.')
      .setTimestamp();

    await interaction.editReply({ embeds: [errorEmbed] });
  }
};

const handleMove = async (interaction, userPuzzle, userMove) => {
  await interaction.deferReply(); // Retour √† la normale

  try {
    const guildId = interaction.guild.id; // Ajouter cette ligne manquante

    // Convertir le coup de l'utilisateur du fran√ßais vers l'anglais pour la validation
    const englishUserMove = convertToEnglish(userMove);

    // Convertir la solution UCI en SAN
    const chess = new Chess();
    chess.loadPgn(userPuzzle.pgn);

    let correctSolutionSAN = [];
    let tempChess = new Chess(chess.fen());

    for (const uciMove of userPuzzle.solution) {
      const move = tempChess.move({
        from: uciMove.slice(0, 2),
        to: uciMove.slice(2, 4),
        promotion: uciMove.length > 4 ? uciMove[4] : undefined
      });
      if (move) {
        correctSolutionSAN.push(move.san);
      }
    }

    // Extraire seulement les coups du joueur (indices pairs)
    const playerMoves = [];
    for (let i = 0; i < correctSolutionSAN.length; i += 2) {
      playerMoves.push(correctSolutionSAN[i]);
    }

    const currentMoveIndex = userPuzzle.userMoves.length;
    const expectedMove = playerMoves[currentMoveIndex];

    // Normaliser les coups pour la comparaison (enlever √©chec, mat, et espaces)
    const normalizeMove = (move) => {
      return move.replace(/[+#\s]/g, '').toLowerCase();
    };

    // Fonction am√©lior√©e pour v√©rifier si les coups correspondent
    const movesMatch = (userMove, expectedMove) => {
      const normalizedUser = normalizeMove(userMove);
      const normalizedExpected = normalizeMove(expectedMove);

      // Comparaison directe
      if (normalizedUser === normalizedExpected) {
        return true;
      }

      // Comparaison apr√®s conversion fran√ßais/anglais
      const convertedUser = normalizeMove(convertToEnglish(userMove));
      if (convertedUser === normalizedExpected) {
        return true;
      }

      return false;
    };

    const isCorrectMove = movesMatch(englishUserMove, expectedMove);

    if (isCorrectMove) {
      // Convertir le coup vers le fran√ßais pour l'affichage
      const frenchMove = convertToFrench(expectedMove);
      userPuzzle.userMoves.push(frenchMove);
      userPuzzle.solvers.push(interaction.user.id);

      // V√©rifier si le puzzle est termin√©
      if (userPuzzle.userMoves.length >= playerMoves.length) {
        // Puzzle termin√© !
        const frenchSolution = correctSolutionSAN.map(move => convertToFrench(move));
        const solversList = [...new Set(userPuzzle.solvers.filter(Boolean))].map(id => `<@${id}>`).join(', ') || 'Aucun';

        const embed = new EmbedBuilder()
          .setColor('#00FF00')
          .setTitle('‚úÖ Puzzle Termin√© !')
          .addFields(
            { name: 'üéØ Solution compl√®te', value: frenchSolution.join(" "), inline: false },
            { name: 'üë§ Coups jou√©s', value: userPuzzle.userMoves.join(" "), inline: false },
            { name: 'üèÜ Contributeurs', value: solversList, inline: false },
            { name: '‚≠ê Rating', value: `${userPuzzle.rating}`, inline: true },
            { name: 'üéØ Difficult√©', value: translateDifficulty(userPuzzle.difficulty), inline: true }
          )
          .setDescription('üéâ F√©licitations ! Le puzzle a √©t√© r√©solu !')
          .setTimestamp()
          .setFooter({ text: 'Utilisez /puzzle pour un autre puzzle' });

        // R√©cup√©rer le message original et le modifier
        const originalMessage = await interaction.channel.messages.fetch(userPuzzle.messageId);
        await originalMessage.edit({
          files: [], // Pas d'image pour le puzzle termin√©
          embeds: [embed],
          components: []
        });

        pendingPuzzles.delete(guildId);
        await interaction.editReply(`üéâ <@${interaction.user.id}> a trouv√© le dernier coup et termin√© le puzzle ! (${frenchMove})`);

      } else {
        // Coup correct mais puzzle pas fini - g√©n√©rer nouvelle position
        await updatePuzzlePosition(interaction, userPuzzle, correctSolutionSAN);
        await interaction.editReply(`‚úÖ <@${interaction.user.id}> a trouv√© un coup correct ! (${frenchMove})`);
      }

    } else {
      // Coup incorrect (message √©ph√©m√®re)
      await interaction.editReply('üîÑ Traitement...');
      await interaction.followUp({
        content: `‚ùå **Coup incorrect !** (${userMove})`,
        flags: MessageFlags.Ephemeral
      });
    }

  } catch (error) {
    console.error("Erreur lors du traitement du coup:", error);
    await interaction.editReply('üîÑ Traitement...');
    await interaction.followUp({
      content: '‚ùå **Erreur** - V√©rifiez la notation de votre coup.',
      flags: MessageFlags.Ephemeral
    });
  }
};

const updatePuzzlePosition = async (interaction, userPuzzle, correctSolutionSAN) => {
  try {
    // Simuler la position apr√®s les coups
    const gameChess = new Chess();
    gameChess.loadPgn(userPuzzle.pgn);

    // Jouer tous les coups jusqu'√† la position actuelle
    const movesToPlay = userPuzzle.userMoves.length * 2;
    let currentGameChess = new Chess(gameChess.fen());

    for (let i = 0; i < movesToPlay && i < correctSolutionSAN.length; i++) {
      currentGameChess.move(correctSolutionSAN[i]);
    }

    const newFen = currentGameChess.fen();
    const fenParts = newFen.split(' ');
    const activeColor = fenParts[1];

    // G√©n√©rer la nouvelle image
    let imageUrl = `https://fen2image.chessvision.ai/${encodeURIComponent(newFen)}`;
    if (activeColor === 'b') {
      imageUrl += '?turn=black&pov=black';
    } else {
      imageUrl += '?turn=white&pov=white';
    }

    const imageResponse = await axios.get(imageUrl, { responseType: 'arraybuffer' });
    const imageBuffer = Buffer.from(imageResponse.data, 'binary');
    const attachment = new AttachmentBuilder(imageBuffer, { name: 'chess_position.png' });

    // Coup de l'adversaire (converti en fran√ßais)
    const opponentMoveIndex = (userPuzzle.userMoves.length - 1) * 2 + 1;
    const opponentMove = opponentMoveIndex < correctSolutionSAN.length ?
      convertToFrench(correctSolutionSAN[opponentMoveIndex]) : null;

    const embed = new EmbedBuilder()
      .setColor('#0099FF')
      .setTitle('üß© Puzzle d\'√âchecs')
      .addFields(
        { name: 'üë• Progression', value: userPuzzle.userMoves.map((move, index) => {
          const solver = userPuzzle.solvers[index] ? `<@${userPuzzle.solvers[index]}>` : 'Inconnu';
          return `${index + 1}. ${move} (${solver})`;
        }).join('\n'), inline: false },
        { name: 'üë§ Trait aux', value: activeColor === 'w' ? 'Blancs' : 'Noirs', inline: true },
        { name: '‚≠ê Rating', value: `${userPuzzle.rating}`, inline: true },
        { name: 'üéØ Difficult√©', value: translateDifficulty(userPuzzle.difficulty), inline: true }
      )
      .setDescription(`${opponentMove ? `L'adversaire a jou√©: **${opponentMove}**\n\n` : ''}**Coup suivant ?**\nCliquez sur les boutons ci-dessous pour interagir avec le puzzle`)
      .setTimestamp()
      .setFooter({ text: 'Puzzle fourni par Lichess.org' });

    // R√©cup√©rer le message original et le modifier
    const originalMessage = await interaction.channel.messages.fetch(userPuzzle.messageId);
    await originalMessage.edit({
      embeds: [embed],
      files: [attachment],
      components: [createPuzzleButtons(), createHintButton()]
    });

    // Mettre √† jour les donn√©es stock√©es
    userPuzzle.fen = newFen;

  } catch (error) {
    console.error("Erreur lors de la mise √† jour de la position:", error);
    throw error;
  }
};

const showHint = async (interaction, userPuzzle) => {
  userPuzzle.hintLevel++;

  // Convertir la solution pour obtenir les infos
  const chess = new Chess();
  chess.loadPgn(userPuzzle.pgn);
  let correctSolutionSAN = [];
  let tempChess = new Chess(chess.fen());

  for (const uciMove of userPuzzle.solution) {
    const move = tempChess.move({
      from: uciMove.slice(0, 2),
      to: uciMove.slice(2, 4),
      promotion: uciMove.length > 4 ? uciMove[4] : undefined
    });
    if (move) {
      correctSolutionSAN.push(move.san);
    }
  }

  const playerMoves = [];
  for (let i = 0; i < correctSolutionSAN.length; i += 2) {
    playerMoves.push(correctSolutionSAN[i]);
  }

  let hintText = "";
  let publicShame = "";

  switch(userPuzzle.hintLevel) {
    case 1:
      hintText = `üí° **Indice 1/3**: Ce puzzle n√©cessite ${playerMoves.length} coup${playerMoves.length > 1 ? 's' : ''} de votre part.`;
      publicShame = `üîî <@${interaction.user.id}> a utilis√© un indice (nombre de coups)`;
      break;
    case 2:
      hintText = `üí° **Indice 2/3**: Th√®mes du puzzle - ${userPuzzle.themes.join(", ")}`;
      publicShame = `üîî <@${interaction.user.id}> a utilis√© un autre indice (th√®mes)`;
      break;
    case 3:
      const currentMoveIndex = userPuzzle.userMoves.length;
      const nextMove = playerMoves[currentMoveIndex];
      const frenchNextMove = convertToFrench(nextMove);
      const firstLetter = frenchNextMove.charAt(0);
      hintText = `üí° **Indice 3/3**: Le prochain coup commence par "${firstLetter}"`;
      publicShame = `üîî <@${interaction.user.id}> a utilis√© le dernier indice (premi√®re lettre)`;
      break;
    default:
      hintText = "‚ùå Aucun indice suppl√©mentaire disponible.";
      return await interaction.reply({ content: hintText, flags: MessageFlags.Ephemeral });
  }

  // Message d'indice priv√©
  await interaction.reply({ content: hintText, flags: MessageFlags.Ephemeral });

  // Message de d√©nonciation publique
  await interaction.followUp({ content: publicShame });
};

const showSolution = async (interaction, userPuzzle) => {
  await interaction.deferReply({ ephemeral: true }); // Rendre la r√©ponse √©ph√©m√®re d√®s le d√©but

  try {
    // Convertir la solution UCI en SAN puis en fran√ßais
    const chess = new Chess();
    chess.loadPgn(userPuzzle.pgn);

    let correctSolutionSAN = [];
    let tempChess = new Chess(chess.fen());

    for (const uciMove of userPuzzle.solution) {
      const move = tempChess.move({
        from: uciMove.slice(0, 2),
        to: uciMove.slice(2, 4),
        promotion: uciMove.length > 4 ? uciMove[4] : undefined
      });
      if (move) {
        correctSolutionSAN.push(move.san);
      }
    }

    const frenchSolution = correctSolutionSAN.map(move => convertToFrench(move));

    const solutionEmbed = new EmbedBuilder()
      .setColor('#FFD700')
      .setTitle('üîç Solution R√©v√©l√©e')
      .addFields(
        { name: '‚úÖ Solution compl√®te', value: frenchSolution.join(" "), inline: false },
        { name: '‚≠ê Rating', value: `${userPuzzle.rating}`, inline: true },
        { name: 'üéØ Difficult√©', value: translateDifficulty(userPuzzle.difficulty), inline: true }
      )
      .setDescription('‚ö†Ô∏è **Vous avez regard√© la solution !**')
      .setTimestamp()
      .setFooter({ text: 'Cette information n\'est visible que par vous' });

    if (userPuzzle.userMoves && userPuzzle.userMoves.length > 0) {
      solutionEmbed.addFields({
        name: 'üë§ Coups d√©j√† trouv√©s',
        value: `${userPuzzle.userMoves.join(" ")} (${userPuzzle.userMoves.length}/${Math.ceil(correctSolutionSAN.length / 2)})`,
        inline: false
      });
    }

    // R√©ponse √©ph√©m√®re avec la solution (ne pas toucher au puzzle principal)
    await interaction.editReply({ embeds: [solutionEmbed] });

    // Message de d√©nonciation publique uniquement
    await interaction.followUp({
      content: `üîî <@${interaction.user.id}> a consult√© la solution du puzzle !`,
      ephemeral: false // S'assurer que c'est public
    });

  } catch (error) {
    console.error("Erreur lors de l'affichage de la solution:", error);

    await interaction.editReply('‚ùå **Erreur** - Impossible d\'afficher la solution.');
  }
};

const showMoveModal = async (interaction) => {
  const modal = new ModalBuilder()
    .setCustomId('move_modal')
    .setTitle('üéØ Jouer un coup');

  const moveInput = new TextInputBuilder()
    .setCustomId('move_input')
    .setLabel('Coup (notation alg√©brique)')
    .setStyle(TextInputStyle.Short)
    .setPlaceholder('Ex: Cf6, e4, O-O, Dxd5+')
    .setRequired(true)
    .setMaxLength(10);

  const actionRow = new ActionRowBuilder().addComponents(moveInput);
  modal.addComponents(actionRow);

  await interaction.showModal(modal);
};

const createPuzzleButtons = () => {
  const playButton = new ButtonBuilder()
    .setCustomId('play_move')
    .setLabel('üéØ Jouer un coup')
    .setStyle(ButtonStyle.Primary);

  const solutionButton = new ButtonBuilder()
    .setCustomId('show_solution')
    .setLabel('üîç Voir la solution')
    .setStyle(ButtonStyle.Secondary);

  return new ActionRowBuilder().addComponents(playButton, solutionButton);
};

const createHintButton = () => {
  const hintButton = new ButtonBuilder()
    .setCustomId('hint_button')
    .setLabel('üí° Indice')
    .setStyle(ButtonStyle.Success);

  return new ActionRowBuilder().addComponents(hintButton);
};
